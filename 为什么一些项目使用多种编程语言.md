参考自 [Why Some Projects Use Multiple Programming Languages]https://www.youtube.com/watch?v=XJC5WB2Bwrc


<img width="739" height="134" alt="FFmpeg仓库使用的语言" src="https://github.com/user-attachments/assets/7090fdfd-e8e7-4286-9ed6-8bbeec343c36" />


之前我经常会在**Github**上看见由各种语言混合的代码仓库，这不经让我疑惑——为什么不仅仅使用一种语言来进行编写呢？比如仅仅使用`C++`或者`Python`实现一个项目。如果使用多种语言混合编写，那么各个语言的代码是如何是如何结合在一起协同工作的？

> 简单来说，不同的编程语言各有其优势。为了满足特定需求，我们’不得不‘灵活地组合多种语言，以实现稳定、高效、安全的操作。**高级语言High-Level Language**通常通过**编译器Compiler**或**解释器Interpreter**转化为**机器语言Machine Language**，让计算机能够识别和执行。这个转化过程可能包括中间表示如**汇编语言Assambly Language**或**字节码Bytecode**的生成，最终由**链接器Linker**或运行时环境将不同语言的代码整合到一个**可执行文件Executable File**中。由于不同语言的规范不同，为了确保不同语言生成的代码能够正确交互并运行，于是我们提出了一个称为**应用二进制接口ABI**的标准规范来约束整合方式。


举个例子，一个简单的`python`温度换算程序可以完全由`Python`代码编写，而在`Django`的**全栈框架Full Stack Framework**中，`python`作为服务器的**后端Backend**负责处理信息，而**HTML**，**CSS**和**JavaScript**则用于构建与用户交互的前端页面。这其实是两个分开的独立**进程Processes**，后端运行在服务器上，前端运行在浏览器中。两者通过某种形式的**进程间通信Interprocess Communication**进行数据交换。

除了独立**进程Processes**, 还有一种方式是将一种编程语言实现的功能嵌入到另一种语言实现的主程序中使用。这种方式更加复杂，但概括起来很简单——通过编译生成符合规范的内容如静态库或动态库，并通过特定桥梁，如**应用二进制接口ABI**，进行交互，以确保两种语言的代码能够正确协作和运行。

现在从单一语言的程序开始，来探讨如何将不同语言作为组件整合到一个项目中。现在我们使用`C`写一个温度转换的应用。
```c
// main.c
#include <stdio.h>

void celsiusToFahrenheit {
    double celsius;
    printf"Enter temperature in Celsius: ";
    scanf"%lf", &celsius;
    double fahrenheit = celsius * 9.0 / 5.0 + 32.0;
    printf"Temperature in Fahrenheit: %.2f°F\n", fahrenheit;
}

void fahrenheitToCelsius {
    double fahrenheit;
    printf"Enter temperature in Fahrenheit: ";
    scanf"%lf", &fahrenheit;
    double celsius = fahrenheit - 32.0 * 5.0 / 9.0;
    printf"Temperature in Celsius: %.2f°C\n", celsius;
}

int main {
    int choice;
    printf"Temperature Converter\n";
    printf"1. Celsius to Fahrenheit\n";
    printf"2. Fahrenheit to Celsius\n";
    printf"Choose an option 1 or 2: ";
    scanf"%d", &choice;

    if choice == 1 {
        celsiusToFahrenheit;
    } else if choice == 2 {
        fahrenheitToCelsius;
    } else {
        printf"Invalid choice. Exiting program.\n";
    }

    return 0;
}
```

我们可以使用**GNU 编译器套套件GNU Compiler Collection-GCC**进行编译。

为了运行这个程序，我们可以在**命令行Terminal**中输入`gcc main.c -o main`，这个命令调用了`GCC`的同时并传递我们想要编译的文件。然后生成一个可执行文件。
```bash
# main.c
$gcc main.c -o main
## main.exe main.c
$./main #运行程序
```

这样简单来看，我们只是使用`GCC`编译程序，然后运行它。事实上，背后的过程要更为复杂。这也是`GCC`编译器做的事情。

GCC内部有四个主要阶段，用于将一个C文件转换为一个可运行的可执行文件。

**第一步：**预处理Pre-processing****

这一步准备源代码，执行诸如移除注释、**展开宏Expanding Macros**、**解析条件编译Resolving Conditional Compilation**，以及关键的**解析包含指令Resolving Includes**。当你使用`#include`时，C**预处理器Pre-processor**会将该行替换为**头文件Header File**的内容以及所有头文件包含的内容，在编译开始之前将这些代码有效地插入到我们的文件中。因此，输出仍然是C代码，但已经预处理并准备好进入下一步。

```bash
main.c main.i
```

**第二步：**编译Compilation****

接下来是编译，但不是直接生成机器码。相反，预处理过的代码被转换为**汇编语言Assambly Language**，这是计算机将执行的指令，但仍然是人类可读的语言。
> 编译器并不总是将源代码转换成**机器码Machine Code**。实际上，许多编译器会将源代码转换为**中间表示Intermediate Representation**。

```bash
main.c main.i main.s
```

**第三步：**汇编Assembly****

第三步涉及**汇编器Assembler**，它技术上是另一个编译器，但它将前一阶段的人类可读汇编代码转换为**机器码Machine Code**。结果被称为**目标文件Object File**。
> 这个**目标文件Object File**还无法运行。`GCC`仍然需要解析函数在二进制文件中的位置。

但是由于我们使用了`printf函数`，而其实际实现位于**C标准库C Standard Library**中。所以该库也需要经过我们刚才描述的相同编译步骤。

```bash
main.c main.i main.s main.o 
studio.c studio.i studio.s studio.o
```

**第四步：**链接Linking****

在这个阶段，我们可能有多个**目标文件Object File**，有些来自我们的代码，有些来自我们在开发过程中包含的外部库。**链接器Linker**的任务是将所有这些**目标文件Object File**组合成一个单一的自包含**可执行文件Executable File**。

有两种方式可以做到这一点：

****静态链接Static Linking**** 
- 从库中获取每个所需函数的**机器码Machine Code**并将其复制到最终的**可执行文件Executable File**中。这称为**静态链接Static Linking**。我们程序需要的所有库函数都直接嵌入到输出文件中。一切都是自包含的，因此可以随时运行。

****动态链接Dynamic Linking****
- 由于很多程序都是用了`printf函数`，那么如果使用**静态链接Static Linking**，那么电脑中就会有无数个包含该函数的副本。而通过**动态链接Dynamic Linking**，这些常用库被预先编译成一种特殊类型的文件——**动态共享库Dynamic Shared Library**
	- 类Unix系统中，这些库的文件扩展名为`.so`。
	- Windows上，它们由`.dll`扩展名标识。

这些**动态共享库Dynamic Shared Library**与**可执行文件Executable File**类似，因为它们包含库提供的函数的可执行代码。
> 关键区别在于它们不包含启动执行的**入口点Entry Point**
> 库通常没有用于启动程序的main函数。

当我们的程序使用**动态链接Dynamic Linking**编译时，**链接器Linker**不会将库中的函数直接复制到**可执行文件Executable File**中。相反，它只是插入一个对包含该函数机器指令的库的**引用Reference**。在运行时，如果程序需要从该动态库中调用某个函数，操作系统会将所需的函数加载到程序的**地址空间Address Space**中，使程序能够像使用**可执行文件Executable File**的一部分一样使用它。

> 与在不同程序中存储相同函数的多个副本相比，系统只存储一次库。每个需要它的程序只需引用共享库，并在运行时按需加载。这既**节省了磁盘空间**，也**节省了内存**。这是一个巨大的优势，特别是在有很多依赖公共库的程序的系统上。它也**更灵活**，因为你可以更新或修补库，而无需重新编译使用该库的每个程序。

这些过程将各种代码模块化，虽然在默认情况下，**编译器Compiler**隐藏了这些中间过程。但是通过正确的命令标志`--save-temps`我们可以编译后得到所有中间文件。

由于程序编译是一步一步进行的，所以，我们可以在特定情况下停止某些过程，或者从这个**流水线Pipeline**中的任意阶段开始进行操作。比如将汇编文件传递给`GCC`，并简单地告诉它进行汇编和链接。
> 这意味着我们可以用汇编编写部分代码，在不同阶段传递给编译器，然后链接器会负责将它们混合到一个可执行文件中。

假设我们需要编写一个程序，计算0到给定数字之间存在多少个质数，并且我们希望它尽可能快。我们可以用C编写整个程序。但假设我们不信任**编译器优化Compiler Optimizations**。所以我们决定直接用汇编编写繁重的计算函数，并从C调用它。然后我们将两个文件传递给GCC，它会编译并汇编C代码，汇编汇编代码，并将两个**目标文件Object File**链接到一个单一的**可执行文件Executable File**中。这就是在一个项目中如何包含多种语言的方式。

<img width="1242" height="441" alt="Is-Prime-C-and-Assambly" src="https://github.com/user-attachments/assets/5ef94128-911f-4c14-a5ee-a60ec5626ab4" />


<img width="1254" height="631" alt="Is-Prime-Rust-and-C" src="https://github.com/user-attachments/assets/ff41bfbd-383e-4cb5-85f9-81f04c865475" />


你可能想在单个项目中混合多种编程语言有几个原因。但我想到的另一个是**性能Performance**。在许多项目中，整个系统不需要极快，只需要某些部分。所以很多开发者做的是用高级语言编写项目的大部分，以获得便利和开发速度，然后只用较低级语言如C实现性能关键组件。

在我们结束之前，还有一个非常重要的点需要理解。假设我们有两种高级语言：语言A和语言B。仅仅因为它们都有最终的**链接Linking**阶段，并不自动意味着它们可以正确地链接到一个**可执行文件Executable File**中。即使两个编译器都产生有效且可执行的汇编，除非双方同意如何相互交流，否则最终链接的二进制文件是不一致的。

这些低级规则由所谓的**应用二进制接口ABI**定义。就像`API`在应用程序级别定义函数一样，`ABI`定义二进制代码的不同组件如何通过硬件相互交互。

所以当我们混合两种不同的语言时，仅仅它们都产生目标文件是不够的。至少其中一个，或者特别是与另一种语言交互的部分，必须符合另一个的`ABI`期望。
